[{"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/App.js":"1","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/index.js":"2","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/indexDb.js":"3","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/basic.js":"4","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/reportWebVitals.js":"5","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/consts.js":"6","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/index.js":"7","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/db.js":"8","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/serviceWorkerRegistration.js":"9"},{"size":2201,"mtime":1608216238906,"results":"10","hashOfConfig":"11"},{"size":773,"mtime":1608257711166,"results":"12","hashOfConfig":"11"},{"size":22916,"mtime":1608257021360,"results":"13","hashOfConfig":"11"},{"size":12047,"mtime":1608177552246,"results":"14","hashOfConfig":"11"},{"size":362,"mtime":1608168097916,"results":"15","hashOfConfig":"11"},{"size":292,"mtime":1608174524573,"results":"16","hashOfConfig":"11"},{"size":360,"mtime":1608176652339,"results":"17","hashOfConfig":"11"},{"size":3993,"mtime":1608254845140,"results":"18","hashOfConfig":"11"},{"size":5063,"mtime":1608257684168,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"5qrl28",{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"24"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/App.js",[],"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/index.js",[],["43","44"],"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/indexDb.js",["45","46","47"],"import React, { Fragment } from 'react'; // eslint-disable-line\nimport { PluginBase } from 'terminal-in-react'; // eslint-disable-line\nimport { autobind, decorate } from 'core-decorators';\nimport memoize from 'memoizerific';\nimport langMap from 'lang-map';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport * as syntaxStyles from 'react-syntax-highlighter/dist/styles';\nimport { displayName, version, CURRENT_DIR, PARENT_DIR, HOME_DIR, DIR, FILE } from './consts';\nimport dbCreator from './db';\n\nconst HOME_PATH = ['', 'home', 'user'];\n\nfunction last(ary) {\n  return ary[ary.length - 1];\n}\n\nfunction parentFolderPath(path) {\n  const len = path.length;\n  if (len - 1 <= 0) {\n    return { parts: [], isRoot: true, isDir: true };\n  }\n  return { parts: path.slice(0, len - 1), isRoot: true, isDir: true };\n}\n\nexport default function configPlugin(pathSeporator = '/', clearDbOnStart = false) {\n  const [db, Folder, File, SuperBlock, InodesList] = dbCreator(pathSeporator, clearDbOnStart);\n\n  function pathFromArgs(args, dir = false) {\n    let path = args._.join(' ').trim();\n    if (dir && last(path) !== pathSeporator) {\n      path += pathSeporator;\n    } else if (!dir && last(path) === pathSeporator) {\n      path = path.slice(0, path.length - 1);\n    }\n    return path;\n  }\n\n  function toStringPath(path) {\n    const stringParts = [...path.parts];\n    if (path.isDir) {\n      stringParts.push('');\n    }\n    if (path.isRoot) {\n      stringParts.unshift('');\n    }\n    return stringParts.join(pathSeporator);\n  }\n\n  function editOrCreateFolder(parent, name) {\n    db.folders.where('fullPath').equals(parent.fullPath + name + pathSeporator)\n    .count((count) => {\n      if (count === 0) {\n        db.inodesList.add(new InodesList(DIR)).then(inode => {\n          db.folders.add(new Folder(name, parent, false, inode)).then(folder => {\n            db.superBlock.get(1).then (function (superBlock) {\n              const { blockSize, freeInodes } = superBlock;\n              let offsetBlockSize = (blockSize + 1024) + 16;\n              let offsetFreeInodes = freeInodes - 8;\n              db.superBlock.update(1, {\n                blockSize: offsetBlockSize,\n                freeInodes: offsetFreeInodes\n              });\n            });\n          });\n        });\n      }\n    });\n  }\n\n  function editOrCreateFile(parent, name, content) {\n    const split = name.split('.');\n    const extention = last(split);\n    const filename = split.slice(0, split.length - 1).join('.');\n    db.files\n      .where('fullPath').equals(parent.fullPath + name)\n      .first((file) => {\n        if (typeof file === 'undefined') {\n          db.inodesList.add(new InodesList(FILE)).then(inode => {\n            db.files.add(new File(filename, extention, parent, content, inode)).then(file => {\n              db.superBlock.get(1).then(superBlock => {\n                const { blockSize, freeInodes } = superBlock;\n                let offsetBlockSize = (blockSize + 1024) + 16;\n                let offsetFreeInodes = freeInodes - 8;\n                db.superBlock.update(1, {\n                  blockSize: offsetBlockSize,\n                  freeInodes: offsetFreeInodes\n                });\n              });\n            });\n          });\n        } else {\n          file.setContents(content);\n        }\n      });\n  }\n\n  function getFolder(path, cb) {\n    const fullPath = toStringPath(path);\n    db.folders.where('fullPath').equals(fullPath).first(cb);\n  }\n\n  function getFile(path, cb) {\n    const fullPath = toStringPath(path);\n    db.files.where('fullPath').equals(fullPath).first(cb);\n  }\n\n  function modifyFileSystem({ parts, isDir }, data) {\n    if (parts.length > 0) {\n      getFolder(parentFolderPath(parts), (parent) => {\n        if (isDir) {\n          editOrCreateFolder(parent, last(parts));\n        } else {\n          editOrCreateFile(parent, last(parts), data);\n        }\n      });\n    }\n  }\n\n  function getContents(path, cb, str = false) {\n    if (path.isDir) {\n      getFolder(path, (folder) => {\n        if (typeof folder === 'undefined') {\n          cb(null);\n        } else if (str) {\n          let items = [];\n          \n          (async () => {\n            let folders = await db.folders.where('folderId').equals(folder.id).toArray((folders) => {\n              return folders;\n            });\n            let files = await db.files.where('folderId').equals(folder.id).toArray((files) => {\n              return files;\n            });\n\n            let newFolders = await Promise.all(folders.map(async folder => {\n              const { inodeID } = folder;\n              if(inodeID) {\n                let ino = await db.inodesList.where('id').equals(inodeID).first(ino => ino);\n                return {\n                  item: folder,\n                  ino\n                };\n              }\n            }));\n\n            let newFiles = await Promise.all(files.map(async file => {\n              const { inodeID } = file;\n              if(inodeID){\n                let ino = await db.inodesList.where('id').equals(inodeID).first(ino => ino);\n                return {\n                  item: file,\n                  ino\n                };\n              }\n            }));\n            cb([...newFolders, ...newFiles]);\n          })();\n\n          /* db.folders.where('folderId').equals(folder.id).toArray((folders) => {\n            db.files.where('folderId').equals(folder.id).toArray((files) => {\n              folders.map(folder => {\n                const { inodeID } = folder;\n                if(inodeID){\n                  db.inodesList.where('id').equals(inodeID).first(ino => {\n                    items.push({\n                      item: folder,\n                      ino\n                    });\n                    cb([...items]);\n                  });\n                }\n              })\n              files.map(file => {\n                const { inodeID } = file;\n                if(inodeID){\n                  db.inodesList.where('id').equals(inodeID).first(ino => {\n                    items.push({\n                      item: file,\n                      ino\n                    });\n                    cb([...items]);\n                  });\n                }\n              })\n            });\n          }); */\n        } else {\n          cb(folder);\n        }\n      });\n    } else {\n      getFile(path, (file) => {\n        if (typeof file === 'undefined') {\n          cb(null);\n        } else if (str) {\n          cb(file.content);\n        } else {\n          cb(file);\n        }\n      });\n    }\n  }\n\n  function removeFromFileSystem(path) {\n    getContents(path, (item) => {\n      if (item !== null) {\n        if (path.isDir) {\n          if (!item.isBase) {\n            db.folders.delete(item.id);\n          }\n        } else {\n          db.files.delete(item.id);\n        }\n      }\n    });\n  }\n\n\n  @autobind\n  class PseudoFileSystem extends PluginBase {\n    static displayName = displayName;\n    static version = version;\n\n    constructor(api, config) {\n      super(api, config);\n\n      this.currentPath = '';\n      window.commands = this.getPublicMethods;\n      window.pathFromArgs = pathFromArgs;\n      window.getContents = getContents;\n\n      const _ = [\n        `${pathSeporator}${HOME_PATH.join(pathSeporator)}${pathSeporator}`,\n      ];\n      this.enterDir().method({ _ });\n    }\n\n    commands = {\n      cd: this.enterDir(),\n      ls: this.listAllDirContents(),\n      /* lsAll: this.listAllDirContents(), */\n      freeInodes: this.freeInodesCommand(),\n      superblock: this.superBlockCommand(),\n      rm: this.removeFromFileSystemCommand(),\n      mkdir: this.createDirCommand(),\n      touch: this.createFileCommand(),\n      cat: this.runCat(),\n      echo: this.runEcho()\n    };\n\n    descriptions = {\n      cd: \"Change directory\",\n      ls: \"List all information of current directory\",\n      freeInodes: \"Get total free inodes\",\n      superblock: \"Get superblock information\",\n      lsAll: false,\n      rm: \"Remove a file or directory\",\n      mkdir: \"Make directory\",\n      touch: \"Create a file\",\n      cat: false,\n      echo: false,\n    };\n\n    getPublicMethods = () => ({\n      parsePath: this.parsePath,\n      isValidPath: this.isValidPath,\n      createDir: this.createDir,\n      createFile: this.createFile,\n      removeDir: this.remove,\n      removeFile: this.remove,\n      readDir: (path, cb) => this.getContents(path, cb, DIR, true),\n      readFile: (path, cb) => this.getContents(path, cb, FILE, true),\n      writeFile: this.writeToFile,\n      pathToString: toStringPath,\n      types: {\n        dir: DIR,\n        file: FILE,\n      },\n    })\n\n    @decorate(memoize(500))\n    doParse(split, currentPath) { // eslint-disable-line class-methods-use-this\n      let isDir = false;\n      let isRoot = false;\n      const baseIsASymbol = [CURRENT_DIR, PARENT_DIR, HOME_DIR].indexOf(split[0]) > -1;\n      if (split[split.length - 1] === '' || (split.length === 1 && baseIsASymbol)) {\n        isDir = true;\n      }\n      if (split[0] === '') {\n        isRoot = true;\n      }\n      let modPath = split.filter(part => part.length !== 0);\n      if (!isRoot) {\n        if (modPath[0] === CURRENT_DIR) {\n          modPath = [...currentPath.parts, ...modPath.slice(1)];\n        } else if (modPath[0] === HOME_DIR) {\n          modPath = [...HOME_PATH, ...modPath.slice(1)];\n        } else if (modPath[0] === PARENT_DIR) {\n          modPath = [...currentPath.parts, ...modPath];\n        }\n      }\n\n      if (baseIsASymbol) {\n        isRoot = true;\n      }\n\n      for (let i = 0; i < modPath.length; i += 1) {\n        if (modPath[i] === CURRENT_DIR) {\n          modPath[i] = '';\n        } else if (modPath[i] === PARENT_DIR) {\n          if (i - 1 >= 0) {\n            modPath[i - 1] = '';\n          }\n          modPath[i] = '';\n        }\n      }\n      modPath = modPath.filter(part => part.length !== 0);\n\n      return {\n        parts: modPath,\n        isRoot,\n        isDir,\n      };\n    }\n\n    parsePath(path) {\n      const split = path.split(pathSeporator);\n      if (['', CURRENT_DIR, PARENT_DIR, HOME_DIR].indexOf(split[0]) < 0) {\n        split.unshift('.');\n      }\n      return this.doParse(split, this.currentPath);\n    }\n\n    isValidPath(path, cb) {\n      const handleRes = (res) => {\n        if (typeof res === 'undefined') {\n          //this.api.printLine(`Not a valid path: ${toStringPath(path)}`);\n          //cb(false);\n          cb(true);\n        } else {\n          cb(true);\n        }\n      };\n      if (path.isDir) {\n        getFolder(path, handleRes);\n      } else {\n        getFile(path, handleRes);\n      }\n    }\n\n    getContents(path, cb, type, str = false) {\n      if ((type === DIR && path.isDir) || (type === FILE && !path.isDir)) {\n        this.isValidPath(path, (valid) => {\n          if (valid) {\n            getContents(path, cb, str);\n          } else {\n            cb(null);\n          }\n        });\n      } else {\n        cb(null);\n      }\n    }\n\n    enterDir() {\n      return {\n        method: (args) => {\n          if (args._.length > 0) {\n            const newPath = this.parsePath(pathFromArgs(args, true));\n            this.isValidPath(newPath, (valid) => {\n              if (valid) {\n                this.currentPath = newPath;\n                this.api.setPromptSymbol(\"$\");\n                this.api.setPromptPrefix(`${toStringPath(this.currentPath)} `);\n              }\n            });\n          }\n        },\n      };\n    }\n\n    getFreeInodesContent(cb){\n      db.superBlock.get(1).then (superBlock => {\n        const { freeInodes, inodeListSize } = superBlock;\n        cb({ freeInodes, inodeListSize });\n      });\n    }\n\n    freeInodesCommand() {\n      return {\n        method: (args) => {\n          this.api.printLine(\n            <span>{\"FREE INODES                     SIZE INODE LIST\"}</span>\n          );\n\n          this.getFreeInodesContent(data => {\n            const { freeInodes, inodeListSize } = data;\n            this.api.printLine(\n              <span>\n                <span>\n                  {`    ${freeInodes}                                ${inodeListSize}`}\n                </span>\n              </span>\n            )\n          });\n        },\n      };\n    }\n\n    getSuperBlockContent(cb){\n      db.superBlock.get(1).then (superBlock => {\n        cb(superBlock);\n      });\n    }\n    superBlockCommand() {\n      return {\n        method: (args) => {\n          this.api.printLine(\n            <span style={{marginBottom: 15}}>{\"SUPER BLOCK\"}</span>\n          );\n\n          this.getSuperBlockContent(data => {\n            const { blockSize, fileSysSize, freeBlocks,\n                    freeInodes, inodeListSize } = data;\n            const column = {\n              width: 'calc(50% - 5px)',\n              display: 'inline-block'\n            };\n            const row = {\n              marginBottom: 5,\n              display: 'block'\n            }\n            this.api.printLine(\n              <Fragment>\n                <span style={row}>\n                  <span style={column}>\n                    Block size\n                  </span>\n                  <span style={column}>\n                    {blockSize}\n                  </span>\n                </span>\n\n                <span style={row}>\n                  <span style={column}>\n                    FileSystem Size\n                  </span>\n                  <span style={column}>\n                    {fileSysSize}\n                  </span>\n                </span>\n\n                <span style={row}>\n                  <span style={column}>\n                    Inode List Size\n                  </span>\n                  <span style={column}>\n                    {inodeListSize}\n                  </span>\n                </span>\n\n                <span style={row}>\n                  <span style={column}>\n                    Free blocks\n                  </span>\n                  <span style={column}>\n                    {freeBlocks}\n                  </span>\n                </span>\n\n                <span style={row}>\n                  <span style={column}>\n                    Free inodes\n                  </span>\n                  <span style={column}>\n                    {freeInodes}\n                  </span>\n                </span>\n              </Fragment>\n            )\n          });\n        },\n      };\n    }\n\n    createDirCommand() {\n      return {\n        method: (args) => {\n          if (args._.length > 0) {\n            const path = this.parsePath(pathFromArgs(args, true));\n            this.createDir(path);\n          }\n        },\n      };\n    }\n\n    createDir(path) {\n      this.isValidPath(parentFolderPath(path.parts), (valid) => {\n        if (valid) {\n          modifyFileSystem(path);\n        }\n      });\n    }\n\n    createFileCommand() {\n      return {\n        method: (args) => {\n          if (args._.length > 0) {\n            const path = this.parsePath(pathFromArgs(args));\n            this.createFile(path);\n          }\n        },\n      };\n    }\n\n    createFile(path) {\n      this.isValidPath(parentFolderPath(path.parts), (valid) => {\n        if (valid) {\n          modifyFileSystem(path, '');\n        }\n      });\n    }\n\n    remove(path) {\n      this.validPath(path, (valid) => {\n        if (valid) {\n          removeFromFileSystem(path);\n        }\n      });\n    }\n\n    removeFromFileSystemCommand() {\n      return {\n        method: (args) => {\n          if (args._.length > 0) {\n            const path = this.parsePath(args._.join(' ').trim());\n            this.validPath(path, (valid) => {\n              if (valid) {\n                if (path.isDir) {\n                  this.getContents(path, (contents) => {\n                    if (contents.length > 0 && !args.recursive) {\n                      this.api.printLine(`${toStringPath(path)} is not empty`);\n                    } else if (contents.length > 0 && !args.force) {\n                      this.api.printLine(`${toStringPath(path)} is not empty`);\n                    } else {\n                      //this.remove(path);\n                    }\n                  }, DIR, true);\n                } else {\n                  //this.remove(path);\n                }\n              }\n            });\n          }\n        },\n        options: [\n          {\n            name: 'recursive',\n            description: 'Each item in the folder as well',\n            defaultValue: false,\n          },\n          {\n            name: 'force',\n            description: 'Force the delete',\n            defaultValue: false,\n          },\n        ],\n      };\n    }\n\n    runCat() {\n      return {\n        method: (args) => {\n          if (args._.length > 0) {\n            let split = args._;\n            if (args._.indexOf('>>') > 0) {\n              split = args._.join(' ').split('>>');\n            }\n            const pathA = this.parsePath(pathFromArgs({ _: split[0].split(' ') }));\n            this.getContents(pathA, (fileA) => {\n              if (fileA !== null) {\n                if (args._.indexOf('>>') > 0) {\n                  const pathB = this.parsePath(pathFromArgs({ _: split[1].split(' ') }));\n                  this.writeToFile(pathB, fileA.content, { flag: 'a' });\n                } else {\n                  const lang = langMap.languages(fileA.extention || '')[0];\n                  this.api.printLine((\n                    <SyntaxHighlighter language={lang} style={syntaxStyles[lang]}>\n                      {fileA.content}\n                    </SyntaxHighlighter>\n                  ));\n                }\n              }\n            }, FILE);\n          }\n        },\n      };\n    }\n\n    runEcho() {\n      return {\n        method: (args) => {\n          if (args._.length > 0) {\n            if (args._.indexOf('>>') > -1) {\n              const split = args._.join(' ').split(' >> ');\n              const path = this.parsePath(pathFromArgs({ _: split[1].split(' ') }));\n              this.writeToFile(path, split[0], { flag: 'a' });\n            } else if (args._.indexOf('>') > -1) {\n              const split = args._.join(' ').split(' > ');\n              const path = this.parsePath(pathFromArgs({ _: split[1].split(' ') }));\n              this.writeToFile(path, split[0], { flag: 'w' });\n            } else {\n              this.api.printLine(args._.join(' '));\n            }\n          }\n        },\n      };\n    }\n\n    writeToFile(path, contents = '', options = { flag: 'w' }) {\n      this.isValidPath(path, (valid) => {\n        if (valid) {\n          this.getContents(path, (file) => {\n            if (file !== null) {\n              let content = file;\n              if (options.flag === 'w') {\n                content = `${contents}`;\n              } else if (options.flag === 'a') {\n                content += `\\n${contents}`;\n              }\n              modifyFileSystem(path, content);\n            }\n          }, FILE, true);\n        }\n      });\n    }\n\n    listDirContents() {\n      return {\n        method: (args) => {\n          const path = this.parsePath(pathFromArgs({ _: (args._.length > 0 ? args._ : ['.']) }, true));\n          if (path.isDir) {\n            this.getContents(path, (dir) => {\n              if (dir !== null) {\n                const contents = [\n                  {\n                    path: '.',\n                    type: DIR,\n                  },\n                  {\n                    path: '..',\n                    type: DIR,\n                  },\n                  ...dir,\n                ];\n                this.api.printLine((\n                  <span>\n                    {contents.map((item) => {\n                      const styles = {\n                        color: '#bdc3c7',\n                        marginRight: 5,\n                        width: 'calc(33% - 5px)',\n                        display: 'inline-block',\n                      };\n                      if (contents.length > 3) {\n                        styles.marginBottom = 5;\n                      }\n                      if (item.type === DIR) {\n                        styles.color = '#2980b9';\n                      }\n                      return (\n                        <span\n                          style={styles}\n                          title={item.type.toUpperCase()}\n                          key={`${item.fullPath}-${item.type}`}\n                        >\n                          {item.type === DIR ? item.path : (item.getFullName())}\n                        </span>\n                      );\n                    })}\n                  </span>\n                ));\n              }\n            }, DIR, true);\n          }\n        },\n      };\n    }\n\n    listAllDirContents() {\n      return {\n        method: (args) => {\n          const path = this.parsePath(pathFromArgs({ _: (args._.length > 0 ? args._ : ['.']) }, true));\n          if (path.isDir) {\n            this.getContents(path, async (dir) => {\n              if (dir !== null) {\n                /* const contents = [\n                  {\n                    path: '.',\n                    type: DIR,\n                  },\n                  {\n                    path: '..',\n                    type: DIR,\n                  },\n                  ...dir,\n                ]; */\n                const contents = dir;\n                this.api.printLine((\n                  <Fragment>\n                    {contents.length > 0 && (\n                      <span>{\"INODE      OWNER      TYPE        NAME\"}</span>\n                    )}\n                    <span>\n                      {contents.map((item) => {\n                        let keyID = 0;\n                        const { path, fullPath } = item.item;\n                        const { owner, type, id } = item.ino;\n\n                        const styles = {\n                          color: '#bdc3c7',\n                          marginRight: 5,\n                          width: 'calc(100% - 5px)',\n                          display: 'block',\n                        };\n                        if (contents.length > 3) {\n                          styles.marginBottom = 5;\n                        }\n                        if (type === DIR) {\n                          styles.color = '#2980b9';\n                        }\n                        \n\n                        keyID = keyID + 1;\n                        return (\n                          <span key={keyID}\n                          style={styles}\n                          title={type.toUpperCase()}\n                          key={`${fullPath}-${type}`}>\n                            {\n                              type === DIR ? (\n                                `${id}          ${owner}       ${type}         ${path}`\n                              ) : (\n                              `${id}          ${owner}       ${type}        ${item.item.getFullName()}`)\n                            }\n                          </span>\n                        )\n                      })}\n                    </span>\n                  </Fragment>\n                ));\n              }\n            }, DIR, true);\n          }\n        },\n      };\n    }\n  }\n\n  return PseudoFileSystem;\n}\n","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/basic.js",[],["48","49"],"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/reportWebVitals.js",[],["50","51"],"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/consts.js",[],"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/index.js",[],"/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/pseudo-system/db.js",["52"],"import Dexie from 'dexie';\nimport { autobind } from 'core-decorators';\nimport { STORAGE_KEY, DIR, FILE } from './consts';\n\nfunction defineDB(pathSeporator) {\n  const db = new Dexie(STORAGE_KEY);\n\n  db.version(1).stores({\n    folders: '++id,&[id+path],folderId,fullPath',\n    files: '++id,&[folderId+filename],filename,extension,folderId,fullPath',\n    superBlock: '++id,blockSize,blocksTotal,fileSysSize,inodeListSize,freeBlocks,freeInodes',\n    inodesList: '++id,type,owner,dateTime,size'\n  });\n\n\n  @autobind\n  class SuperBlock {\n    constructor(\n      blockSize = 1024, blocksTotal = 1024,\n      fileSysSize = 1024 * 1024, inodeListSize = 8192,\n      freeBlocks = 1024 - 12, freeInodes = 8192) {\n      this.blockSize = blockSize;\n      this.blocksTotal = blocksTotal;\n      this.fileSysSize = fileSysSize;\n      this.inodeListSize = inodeListSize;\n      this.freeBlocks = freeBlocks;\n      this.freeInodes = freeInodes;\n    }\n\n    save() {\n      return db.superBlock.put(this);\n    }\n  }\n\n  @autobind\n  class InodesList {\n    constructor(\n      type,\n      owner='user',\n      dateTime=new Date(),\n      size=64\n    )\n       {\n      this.type = type;\n      this.owner = owner;\n      this.dateTime = dateTime;\n      this.size = size;\n    }\n\n    save() {\n      return db.inodesList.put(this);\n    }\n  }\n\n  @autobind\n  class Folder {\n    constructor(path, parentFolder = { fullPath: '' }, base = false, inodeID=0) {\n      this.path = path;\n      this.fullPath = parentFolder.fullPath + path + pathSeporator;\n      this.folderId = parentFolder.id;\n      this.type = DIR;\n      this.isBase = base;\n      this.inodeID = inodeID;\n    }\n\n    save() {\n      return db.folders.put(this);\n    }\n  }\n\n  @autobind\n  class File {\n    constructor(filename, extention, parentFolder, contents = '',inodeID=0) {\n      this.fullPath = `${parentFolder.fullPath + filename}.${extention}`;\n      this.filename = filename;\n      this.extention = extention;\n      this.folderId = parentFolder.id;\n      this.content = contents;\n      this.type = FILE;\n      this.inodeID = inodeID;\n    }\n\n    setContents(contents = '') {\n      this.content = contents;\n      this.save();\n    }\n\n    getFullName() {\n      return (this.filename || '') + (this.extention ? '.' : '') + (this.extention || '');\n    }\n\n    save() {\n      return db.files.put(this);\n    }\n  }\n\n  db.folders.mapToClass(Folder);\n  db.files.mapToClass(File);\n  db.superBlock.mapToClass(SuperBlock);\n  db.inodesList.mapToClass(InodesList);\n\n  return [db, Folder, File, SuperBlock, InodesList];\n}\n\nexport default function(pathSeporator, clear) {\n  if (clear) {\n    Dexie.delete(STORAGE_KEY);\n  }\n  const [db, Folder, File, SuperBlock, InodesList] = defineDB(pathSeporator);\n  db.superBlock.count(async count => {\n    if(count === 0){\n      let id = await db.superBlock.add(new SuperBlock());\n      if(id) {\n        \n        let inodeID = await db.inodesList.add(new InodesList(DIR));\n        if(inodeID) {\n          await db.folders.add(new Folder('', { fullPath: '' }, true, inodeID));\n          inodeID = 0;\n        }\n        \n        db.folders.toCollection().first().then(async item => {\n          let inodeID = await db.inodesList.add(new InodesList(DIR));\n          if(inodeID) {\n            await db.folders.add(new Folder('home', item, false, inodeID));\n            inodeID = 0;\n          }\n          inodeID = await db.inodesList.add(new InodesList(DIR));\n          if(inodeID){\n            await db.folders.add(new Folder('user', { fullPath: `${item.fullPath}home${pathSeporator}`, id: item.id + 1 }, false, inodeID)).then(folder => {\n              let offsetblockSize = (folder * 1024) + (16 * 3); //Cause we initialized three dirs.\n              let offsetFreeInodes = 8192 - (8 * 3);\n              db.superBlock.update(1, {\n                blockSize: offsetblockSize,\n                freeInodes: offsetFreeInodes\n              });\n            });\n          }\n        });\n      }\n    }\n  });\n\n  return [db, Folder, File, SuperBlock, InodesList];\n}\n","/home/hoose/Maestria/SistemasOperativos/ProyectoFinal/terminal-react/src/serviceWorkerRegistration.js",[],{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","replacedBy":"56"},{"ruleId":"57","severity":1,"message":"58","line":26,"column":28,"nodeType":"59","messageId":"60","endLine":26,"endColumn":38},{"ruleId":"57","severity":1,"message":"61","line":125,"column":15,"nodeType":"59","messageId":"60","endLine":125,"endColumn":20},{"ruleId":"62","severity":1,"message":"63","line":739,"column":27,"nodeType":"64","endLine":739,"endColumn":54},{"ruleId":"53","replacedBy":"65"},{"ruleId":"55","replacedBy":"66"},{"ruleId":"53","replacedBy":"67"},{"ruleId":"55","replacedBy":"68"},{"ruleId":"69","severity":1,"message":"70","line":105,"column":1,"nodeType":"71","endLine":144,"endColumn":2},"no-native-reassign",["72"],"no-negated-in-lhs",["73"],"no-unused-vars","'SuperBlock' is assigned a value but never used.","Identifier","unusedVar","'items' is assigned a value but never used.","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute",["72"],["73"],["72"],["73"],"import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","no-global-assign","no-unsafe-negation"]